import { ipcMain, dialog } from 'electron';
import { IPC_CHANNELS } from '../../shared/types';
import { getDatabase } from '../database/database';
import { VideoScanner } from '../video/video-scanner';

const db = getDatabase();
const videoScanner = new VideoScanner();

export function setupIpcHandlers(): void {
  // Handle folder selection
  ipcMain.handle(IPC_CHANNELS.SELECT_FOLDER, async () => {
    try {
      const result = await dialog.showOpenDialog({
        properties: ['openDirectory'],
        title: 'Select Video Folder'
      });

      if (result.canceled || result.filePaths.length === 0) {
        return null;
      }

      return result.filePaths[0];
    } catch (error) {
      console.error('Error selecting folder:', error);
      throw error;
    }
  });

  // Handle video scanning
  ipcMain.handle(IPC_CHANNELS.SCAN_VIDEOS, async (event, folderPath: string) => {
    try {
      const videos = await videoScanner.scanFolder(folderPath);
      return videos;
    } catch (error) {
      console.error('Error scanning videos:', error);
      throw error;
    }
  });

  // Handle getting all videos
  ipcMain.handle(IPC_CHANNELS.GET_VIDEOS, async () => {
    try {
      return db.getAllVideos();
    } catch (error) {
      console.error('Error getting videos:', error);
      throw error;
    }
  });

  // Handle search
  ipcMain.handle(IPC_CHANNELS.SEARCH_VIDEOS, async (event, query: string) => {
    console.log('ðŸ” IPC: SEARCH_VIDEOS handler called with query:', query);
    
    try {
      if (!query.trim()) {
        console.log('ðŸ” IPC: Empty query, returning empty array');
        return [];
      }
      
      console.log('ðŸ” IPC: Calling db.searchTranscripts with:', query);
      const results = db.searchTranscripts(query);
      console.log('ðŸ” IPC: Database search results:', results);
      console.log('ðŸ” IPC: Number of results from database:', results.length);
      
      if (results.length > 0) {
        console.log('ðŸ” IPC: First result from database:', results[0]);
      }
      
      return results;
    } catch (error) {
      console.error('ðŸ” IPC: Error searching videos:', error);
      throw error;
    }
  });

  // Handle getting transcript for a video
  ipcMain.handle(IPC_CHANNELS.GET_TRANSCRIPT, async (event, videoId: number) => {
    try {
      return db.getTranscriptSegments(videoId);
    } catch (error) {
      console.error('Error getting transcript:', error);
      throw error;
    }
  });

  // Handle transcription (placeholder for MVP)
  ipcMain.handle(IPC_CHANNELS.TRANSCRIBE_VIDEO, async (event, videoId: number) => {
    try {
      // For MVP, we'll just mark as completed with dummy data
      // In full implementation, this would trigger actual transcription
      
      // Update status to processing
      db.updateVideoTranscriptionStatus(videoId, 'processing');
      
      // Simulate transcription delay
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Add dummy transcript segments
      const dummySegments = [
        {
          startTime: 0,
          endTime: 5,
          text: "This is a sample transcript segment for testing purposes.",
          confidence: 0.95
        },
        {
          startTime: 5,
          endTime: 10,
          text: "In a real implementation, this would be generated by Whisper AI.",
          confidence: 0.92
        },
        {
          startTime: 10,
          endTime: 15,
          text: "The transcription would include actual spoken content from the video.",
          confidence: 0.88
        }
      ];
      
      db.insertTranscriptSegments(videoId, dummySegments);
      db.updateVideoTranscriptionStatus(videoId, 'completed');
      
      return { success: true, message: 'Transcription completed' };
    } catch (error) {
      console.error('Error transcribing video:', error);
      db.updateVideoTranscriptionStatus(videoId, 'failed');
      throw error;
    }
  });
}
